# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sorbet-result` gem.
# Please instead update this file by running `bin/tapioca gem sorbet-result`.

# source://sorbet-result//lib/sorbet-result.rb#10
module Typed; end

# Represents a failed result. Contains error information but no payload.
#
# source://sorbet-result//lib/typed/failure.rb#6
class Typed::Failure < ::Typed::Result
  extend T::Generic

  Payload = type_member { { fixed: T.noreturn } }
  Error = type_member

  # source://sorbet-result//lib/typed/failure.rb#31
  sig { params(error: Error).void }
  def initialize(error); end

  # source://sorbet-result//lib/typed/failure.rb#57
  sig do
    override
      .type_parameters(:U, :T)
      .params(
        _block: T.proc.params(arg0: Payload).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
      ).returns(Typed::Result[T.type_parameter(:U), Error])
  end
  def and_then(&_block); end

  # source://sorbet-result//lib/typed/failure.rb#14
  sig { override.returns(Error) }
  def error; end

  # source://sorbet-result//lib/typed/failure.rb#42
  sig { override.returns(T::Boolean) }
  def failure?; end

  # source://sorbet-result//lib/typed/failure.rb#66
  sig { override.params(block: T.proc.params(arg0: Error).void).returns(T.self_type) }
  def on_error(&block); end

  # @raise [NoPayloadOnFailureError]
  #
  # source://sorbet-result//lib/typed/failure.rb#47
  sig { override.returns(T.noreturn) }
  def payload; end

  # source://sorbet-result//lib/typed/failure.rb#77
  sig do
    override
      .type_parameters(:Fallback)
      .params(
        value: T.type_parameter(:Fallback)
      ).returns(T.any(Payload, T.type_parameter(:Fallback)))
  end
  def payload_or(value); end

  # source://sorbet-result//lib/typed/failure.rb#37
  sig { override.returns(T::Boolean) }
  def success?; end

  class << self
    # source://sorbet-result//lib/typed/failure.rb#26
    sig { returns(Typed::Failure[::NilClass]) }
    def blank; end

    # source://sorbet-result//lib/typed/failure.rb#21
    sig { type_parameters(:T).params(error: T.type_parameter(:T)).returns(Typed::Failure[T.type_parameter(:T)]) }
    def new(error); end
  end
end

# Error when user attempts to access payload from a Failure Result.
#
# source://sorbet-result//lib/typed/no_error_on_success_error.rb#6
class Typed::NoErrorOnSuccessError < ::StandardError
  # source://sorbet-result//lib/typed/no_error_on_success_error.rb#10
  sig { void }
  def initialize; end
end

# Error when user attempts to access payload from a Failure Result.
#
# source://sorbet-result//lib/typed/no_payload_on_failure_error.rb#6
class Typed::NoPayloadOnFailureError < ::StandardError
  # source://sorbet-result//lib/typed/no_payload_on_failure_error.rb#10
  sig { void }
  def initialize; end
end

# A monad representing either a success or a failure. Contains payload and error information as well.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://sorbet-result//lib/typed/result.rb#6
class Typed::Result
  extend T::Generic

  abstract!

  Payload = type_member(:out)
  Error = type_member(:out)

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#34
  sig do
    abstract
      .type_parameters(:U, :T)
      .params(
        _block: T.proc.params(arg0: Payload).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
      ).returns(T.any(Typed::Result[T.type_parameter(:U), Error], Typed::Result[T.type_parameter(:U), T.type_parameter(:T)]))
  end
  def and_then(&_block); end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#26
  sig { abstract.returns(Error) }
  def error; end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#20
  sig { abstract.returns(T::Boolean) }
  def failure?; end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#41
  sig { abstract.params(block: T.proc.params(arg0: Error).void).returns(T.self_type) }
  def on_error(&block); end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#23
  sig { abstract.returns(Payload) }
  def payload; end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#49
  sig do
    abstract
      .type_parameters(:Fallback)
      .params(
        value: T.type_parameter(:Fallback)
      ).returns(T.any(Payload, T.type_parameter(:Fallback)))
  end
  def payload_or(value); end

  # @abstract
  #
  # source://sorbet-result//lib/typed/result.rb#17
  sig { abstract.returns(T::Boolean) }
  def success?; end
end

# Represents a successful result. Contains a payload and no error information.
#
# source://sorbet-result//lib/typed/success.rb#6
class Typed::Success < ::Typed::Result
  extend T::Generic

  Payload = type_member
  Error = type_member { { fixed: T.noreturn } }

  # source://sorbet-result//lib/typed/success.rb#31
  sig { params(payload: Payload).void }
  def initialize(payload); end

  # source://sorbet-result//lib/typed/success.rb#57
  sig do
    override
      .type_parameters(:U, :T)
      .params(
        block: T.proc.params(arg0: Payload).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
      ).returns(Typed::Result[T.type_parameter(:U), T.type_parameter(:T)])
  end
  def and_then(&block); end

  # @raise [NoErrorOnSuccessError]
  #
  # source://sorbet-result//lib/typed/success.rb#47
  sig { override.returns(T.noreturn) }
  def error; end

  # source://sorbet-result//lib/typed/success.rb#42
  sig { override.returns(T::Boolean) }
  def failure?; end

  # source://sorbet-result//lib/typed/success.rb#66
  sig { override.params(_block: T.proc.params(arg0: Error).void).returns(T.self_type) }
  def on_error(&_block); end

  # source://sorbet-result//lib/typed/success.rb#14
  sig { override.returns(Payload) }
  def payload; end

  # source://sorbet-result//lib/typed/success.rb#76
  sig do
    override
      .type_parameters(:Fallback)
      .params(
        _value: T.type_parameter(:Fallback)
      ).returns(T.any(Payload, T.type_parameter(:Fallback)))
  end
  def payload_or(_value); end

  # source://sorbet-result//lib/typed/success.rb#37
  sig { override.returns(T::Boolean) }
  def success?; end

  class << self
    # source://sorbet-result//lib/typed/success.rb#26
    sig { returns(Typed::Success[::NilClass]) }
    def blank; end

    # source://sorbet-result//lib/typed/success.rb#21
    sig { type_parameters(:T).params(payload: T.type_parameter(:T)).returns(Typed::Success[T.type_parameter(:T)]) }
    def new(payload); end
  end
end
